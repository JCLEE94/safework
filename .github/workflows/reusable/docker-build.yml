name: Reusable Docker Build

on:
  workflow_call:
    inputs:
      dockerfile:
        description: 'Path to Dockerfile'
        required: false
        type: string
        default: 'deployment/Dockerfile.prod'
      context:
        description: 'Docker build context'
        required: false
        type: string
        default: '.'
      platforms:
        description: 'Target platforms'
        required: false
        type: string
        default: 'linux/amd64,linux/arm64'
      registry:
        description: 'Docker registry URL'
        required: false
        type: string
        default: 'registry.jclee.me'
      image-name:
        description: 'Docker image name'
        required: false
        type: string
        default: 'safework'
      push:
        description: 'Push image to registry'
        required: false
        type: boolean
        default: true
      cache-enabled:
        description: 'Enable build cache'
        required: false
        type: boolean
        default: true
    secrets:
      REGISTRY_USERNAME:
        required: true
      REGISTRY_PASSWORD:
        required: true
    outputs:
      image-tag:
        description: 'Generated image tag'
        value: ${{ jobs.build.outputs.tag }}
      image-digest:
        description: 'Image digest'
        value: ${{ jobs.build.outputs.digest }}
      image-uri:
        description: 'Full image URI'
        value: ${{ jobs.build.outputs.uri }}
      sbom-artifact:
        description: 'SBOM artifact name'
        value: ${{ jobs.build.outputs.sbom }}

jobs:
  build:
    runs-on: [self-hosted, linux]
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
      digest: ${{ steps.docker-build.outputs.digest }}
      uri: ${{ steps.meta.outputs.uri }}
      sbom: sbom-${{ github.run_id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      # 빌드 메타데이터 생성
      - name: Generate build metadata
        id: meta
        run: |
          # Determine environment and version
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            ENV="pr-${{ github.event.pull_request.number }}"
            VERSION="pr${{ github.event.pull_request.number }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENV="prod"
            VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "v0.0.0")
          elif [[ "${{ github.ref }}" == refs/heads/* ]]; then
            ENV="dev"
            BRANCH=$(echo ${GITHUB_REF#refs/heads/} | sed 's/[^a-zA-Z0-9]/-/g')
            VERSION="dev-${BRANCH}"
          else
            ENV="dev"
            VERSION="dev"
          fi
          
          # Generate semantic version
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          BUILD_NUM=${{ github.run_number }}
          SHA_SHORT=${GITHUB_SHA:0:7}
          
          # Create different tag formats
          TAG="${ENV}-${TIMESTAMP}-${SHA_SHORT}"
          SEMVER_TAG="${VERSION}-${BUILD_NUM}"
          
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "semver-tag=${SEMVER_TAG}" >> $GITHUB_OUTPUT
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "uri=${{ inputs.registry }}/${{ inputs.image-name }}:${TAG}" >> $GITHUB_OUTPUT
          
          # Generate OCI labels
          cat > docker-labels.txt <<EOF
          org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          org.opencontainers.image.authors=SafeWork Pro Team
          org.opencontainers.image.url=https://github.com/${{ github.repository }}
          org.opencontainers.image.documentation=https://github.com/${{ github.repository }}/blob/main/README.md
          org.opencontainers.image.source=https://github.com/${{ github.repository }}
          org.opencontainers.image.version=${VERSION}
          org.opencontainers.image.revision=${{ github.sha }}
          org.opencontainers.image.vendor=SafeWork Pro
          org.opencontainers.image.licenses=MIT
          org.opencontainers.image.ref.name=${{ github.ref }}
          org.opencontainers.image.title=SafeWork Pro
          org.opencontainers.image.description=Construction site health management system
          com.safework.build.number=${BUILD_NUM}
          com.safework.build.timestamp=${TIMESTAMP}
          com.safework.build.environment=${ENV}
          com.safework.git.branch=${{ github.ref_name }}
          com.safework.git.commit=${{ github.sha }}
          com.safework.git.commit.short=${SHA_SHORT}
          EOF
      
      # Docker Buildx 설정
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
            image=moby/buildkit:master
          buildkitd-flags: --debug
          config-inline: |
            [registry."${{ inputs.registry }}"]
              mirrors = ["https://${{ inputs.registry }}"]
      
      # QEMU 설정 (멀티 플랫폼 빌드용)
      - name: Set up QEMU
        if: contains(inputs.platforms, 'arm')
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64,arm
      
      # 레지스트리 로그인
      - name: Login to Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}
      
      # 빌드 캐시 준비
      - name: Prepare build cache
        if: inputs.cache-enabled
        run: |
          # Local cache directory
          mkdir -p /tmp/.buildx-cache
          
          # Cache key based on dockerfile and dependencies
          CACHE_KEY=$(echo -n "${{ hashFiles(inputs.dockerfile, '**/requirements*.txt', '**/package*.json', '**/go.sum', '**/Gemfile.lock') }}" | sha256sum | cut -d' ' -f1)
          echo "CACHE_KEY=${CACHE_KEY}" >> $GITHUB_ENV
      
      # Docker 이미지 빌드
      - name: Build Docker image
        id: docker-build
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.context }}
          file: ${{ inputs.dockerfile }}
          platforms: ${{ inputs.platforms }}
          push: ${{ inputs.push }}
          tags: |
            ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.tag }}
            ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.semver-tag }}
            ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.environment }}
            ${{ inputs.registry }}/${{ inputs.image-name }}:latest
            ${{ inputs.registry }}/${{ inputs.image-name }}:cache
          labels: |
            $(cat docker-labels.txt)
          cache-from: |
            type=registry,ref=${{ inputs.registry }}/${{ inputs.image-name }}:cache
            type=local,src=/tmp/.buildx-cache
            type=gha,scope=${{ inputs.image-name }}-${{ steps.meta.outputs.environment }}
          cache-to: |
            type=registry,ref=${{ inputs.registry }}/${{ inputs.image-name }}:cache,mode=max
            type=local,dest=/tmp/.buildx-cache-new,mode=max
            type=gha,mode=max,scope=${{ inputs.image-name }}-${{ steps.meta.outputs.environment }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            BUILD_NUMBER=${{ github.run_number }}
            VCS_REF=${{ github.sha }}
            VCS_BRANCH=${{ github.ref_name }}
            VERSION=${{ steps.meta.outputs.version }}
            ENVIRONMENT=${{ steps.meta.outputs.environment }}
          outputs: |
            type=image,name=${{ inputs.registry }}/${{ inputs.image-name }},push=${{ inputs.push }}
            type=docker,dest=/tmp/image.tar
          provenance: true
          sbom: true
      
      # 캐시 정리
      - name: Move cache
        if: inputs.cache-enabled
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true
      
      # 이미지 스캔
      - name: Scan Docker image
        if: inputs.push
        run: |
          # Trivy scan
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            -v $HOME/.cache/trivy:/root/.cache/ \
            aquasec/trivy:latest image \
            --exit-code 0 \
            --severity HIGH,CRITICAL \
            --format json \
            --output trivy-scan.json \
            ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.tag }}
          
          # Grype scan (alternative)
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            anchore/grype:latest \
            ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.tag }} \
            -o json > grype-scan.json || true
          
          # Summary
          echo "📊 Vulnerability scan summary:"
          jq '.Results[0].Vulnerabilities | group_by(.Severity) | map({severity: .[0].Severity, count: length})' trivy-scan.json || true
      
      # SBOM 생성
      - name: Generate SBOM
        if: inputs.push
        run: |
          # Syft SBOM generation
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            anchore/syft:latest \
            ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.tag }} \
            -o spdx-json > sbom.spdx.json
          
          # CycloneDX format
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            anchore/syft:latest \
            ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.tag }} \
            -o cyclonedx-json > sbom.cyclonedx.json
          
          echo "📦 SBOM generated successfully"
      
      # 이미지 서명 (Cosign)
      - name: Sign container image
        if: inputs.push && env.COSIGN_KEY
        env:
          COSIGN_EXPERIMENTAL: 1
          COSIGN_KEY: ${{ secrets.COSIGN_KEY }}
        run: |
          # Install cosign
          curl -LO https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
          chmod +x cosign-linux-amd64
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign
          
          # Sign the image
          cosign sign --key env://COSIGN_KEY \
            ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.tag }} || true
          
          # Attach SBOM
          cosign attach sbom --sbom sbom.spdx.json \
            ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.tag }} || true
          
          # Verify signature
          cosign verify --key env://COSIGN_KEY \
            ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.tag }} || true
      
      # 빌드 아티팩트 업로드
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: docker-build-${{ github.run_id }}
          path: |
            trivy-scan.json
            grype-scan.json
            sbom.*.json
            docker-labels.txt
          retention-days: 30
      
      # 빌드 요약
      - name: Build summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY <<EOF
          # 🐳 Docker Build Summary
          
          ## Image Details
          - **Registry**: \`${{ inputs.registry }}\`
          - **Repository**: \`${{ inputs.image-name }}\`
          - **Tag**: \`${{ steps.meta.outputs.tag }}\`
          - **Digest**: \`${{ steps.docker-build.outputs.digest }}\`
          - **Platforms**: \`${{ inputs.platforms }}\`
          
          ## Pull Command
          \`\`\`bash
          docker pull ${{ inputs.registry }}/${{ inputs.image-name }}:${{ steps.meta.outputs.tag }}
          \`\`\`
          
          ## Build Info
          - **Environment**: ${{ steps.meta.outputs.environment }}
          - **Version**: ${{ steps.meta.outputs.version }}
          - **Build Number**: ${{ github.run_number }}
          - **Commit**: ${{ github.sha }}
          
          ## Security Scans
          - ✅ Trivy vulnerability scan completed
          - ✅ SBOM generated (SPDX and CycloneDX formats)
          - $([ -n "$COSIGN_KEY" ] && echo "✅ Image signed with Cosign" || echo "⚠️ Image not signed (no COSIGN_KEY)")
          EOF