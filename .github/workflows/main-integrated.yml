name: SafeWork Pro - CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

env:
  REGISTRY_URL: registry.jclee.me
  IMAGE_NAME: safework
  DOCKER_BUILDKIT: 1

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  claude-analysis:
    name: Claude AI MCP Analysis
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    outputs:
      review-status: ${{ steps.analysis.outputs.status }}
      critical-issues: ${{ steps.analysis.outputs.critical }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Load MCP Configuration
        id: mcp
        run: |
          if [ -f ".mcp.json" ]; then
            echo "üîç MCP configuration found"
            MCP_CONFIG=$(cat .mcp.json | jq -c .)
            echo "config<<EOF" >> $GITHUB_OUTPUT
            echo "$MCP_CONFIG" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "config={}" >> $GITHUB_OUTPUT
          fi
      
      - name: Prepare Claude Prompt
        id: prompt
        run: |
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || echo "")
          
          cat > claude-prompt.txt <<'EOF'
          SafeWork Pro MCP Î∂ÑÏÑù ÏãúÏä§ÌÖúÏùÑ Ïã§ÌñâÌï©ÎãàÎã§.
          
          üéØ SYSTEMATIC MCP-POWERED ANALYSIS:
          
          **STEP 1: Context Gathering with MCP Tools**
          1. mcp__github__search_issues with "security"
          2. mcp__github__search_pull_requests with "fix"  
          3. mcp__memory__search_nodes with "safework review"
          4. mcp__brave-search__brave_web_search for "Korean medical data protection law 2024"
          5. mcp__sequential-thinking__sequentialthinking for analysis strategy
          
          **STEP 2: Code Pattern Analysis**
          1. mcp__github__get_file_contents on each changed file
          2. mcp__memory__create_entities for critical findings
          3. mcp__sequential-thinking for security analysis
          4. mcp__brave-search for Korean compliance:
             - "ÏùòÎ£åÎ≤ï Í∞úÏù∏Ï†ïÎ≥¥Î≥¥Ìò∏ requirements 2024"
             - "Korean healthcare data encryption standards"
          
          **STEP 3: Knowledge Graph Building**
          1. Create entities for each vulnerability
          2. Create relations between vulnerabilities and compliance
          3. Add observations about fix recommendations
          
          **STEP 4: Comprehensive Security Review**
          - SQL injection patterns
          - XSS vulnerabilities  
          - Authentication/authorization flaws
          - Korean medical data compliance (ÏùòÎ£åÎ≤ï)
          - Personal information protection (Í∞úÏù∏Ï†ïÎ≥¥Î≥¥Ìò∏Î≤ï)
          - HTTPS/TLS configuration
          - Input validation on medical data
          - Audit logging for patient data access
          
          **STEP 5: Generate Report & Auto-Fix**
          - Critical issues ‚Üí GitHub Issues
          - Auto-fix simple issues using MCP tools
          - Warning issues ‚Üí PR comments
          - Korean law compliance status
          
          üîß CHANGED FILES:
EOF
          echo "$CHANGED_FILES" >> claude-prompt.txt
          
          echo "prompt<<EOF" >> $GITHUB_OUTPUT
          cat claude-prompt.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Run Claude MCP Analysis
        id: analysis
        uses: anthropics/claude-code-base-action@beta
        with:
          mcp_config: ${{ steps.mcp.outputs.config }}
          allowed_tools: "Bash(git:*),View,GlobTool,GrepTool,mcp__github__*,mcp__memory__*,mcp__sequential-thinking__*,mcp__brave-search__*,mcp__serena__*"
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: ${{ steps.prompt.outputs.prompt }}
      
      - name: Parse Analysis Results
        id: parse
        run: |
          # Claude Î∂ÑÏÑù Í≤∞Í≥ºÏóêÏÑú Ï§ëÏöîÎèÑÎ≥Ñ Ïù¥Ïäà Í∞úÏàò Ï∂îÏ∂ú
          CRITICAL=$(echo "${{ steps.analysis.outputs.result }}" | grep -c "üö® CRITICAL" || echo "0")
          WARNING=$(echo "${{ steps.analysis.outputs.result }}" | grep -c "‚ö†Ô∏è WARNING" || echo "0")
          INFO=$(echo "${{ steps.analysis.outputs.result }}" | grep -c "üí° INFO" || echo "0")
          
          echo "critical=$CRITICAL" >> $GITHUB_OUTPUT
          echo "warning=$WARNING" >> $GITHUB_OUTPUT
          echo "info=$INFO" >> $GITHUB_OUTPUT
          
          if [ "$CRITICAL" -gt 0 ]; then
            echo "status=failed" >> $GITHUB_OUTPUT
          elif [ "$WARNING" -gt 0 ]; then
            echo "status=warning" >> $GITHUB_OUTPUT
          else
            echo "status=passed" >> $GITHUB_OUTPUT
          fi
      
      - name: Create Issues for Critical Findings
        if: steps.parse.outputs.critical > 0
        uses: actions/github-script@v7
        with:
          script: |
            const result = `${{ steps.analysis.outputs.result }}`;
            const criticalIssues = result.match(/üö® CRITICAL:.*?(?=üö®|‚ö†Ô∏è|üí°|$)/gs) || [];
            
            for (const issue of criticalIssues) {
              const title = issue.match(/üö® CRITICAL: (.+)/)?.[1] || 'Critical Security Issue';
              const body = `## üö® Claude AIÍ∞Ä Î∞úÍ≤¨Ìïú Ï§ëÏöî Î≥¥Ïïà Ïù¥Ïäà
              
${issue}

**Ïª§Î∞ã**: ${context.sha.substring(0, 7)}
**Î∏åÎûúÏπò**: ${context.ref}
**Î∂ÑÏÑù ÏãúÍ∞Ñ**: ${new Date().toISOString()}

---
*Ïù¥ Ïù¥ÏäàÎäî Claude AI MCP Î∂ÑÏÑù ÏãúÏä§ÌÖúÏóê ÏùòÌï¥ ÏûêÎèô ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.*`;
              
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[Claude AI] ${title}`,
                body: body,
                labels: ['security', 'critical', 'claude-ai']
              });
            }

  test:
    name: Test Suite
    runs-on: [self-hosted, linux]
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: admin
          POSTGRES_PASSWORD: password
          POSTGRES_DB: health_management
        ports:
          - 25432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
          
      redis:
        image: redis:7-alpine
        ports:
          - 26379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install backend dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install pytest pytest-cov pytest-asyncio pytest-timeout
      
      - name: Run backend tests
        env:
          DATABASE_URL: postgresql://admin:password@localhost:25432/health_management
          REDIS_URL: redis://localhost:26379/0
          JWT_SECRET: test-secret-key
          PYTHONPATH: ${{ github.workspace }}
        timeout-minutes: 10
        run: |
          echo "üß™ Running backend tests..."
          pytest tests/ -v --cov=src --cov-report=term --cov-fail-under=70 --timeout=300 -x
      
      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci
      
      - name: Run frontend tests
        working-directory: frontend
        run: |
          npm run lint
          npm run test -- --passWithNoTests
          npm run build

  build:
    name: Build Docker Image
    needs: [test]
    runs-on: [self-hosted, linux]
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Generate metadata
        id: meta
        run: |
          VERSION=$(date +%Y.%m.%d)
          BUILD_NUM=${{ github.run_number }}
          SHA_SHORT=${GITHUB_SHA:0:7}
          TAG="prod-${VERSION}.${BUILD_NUM}-${SHA_SHORT}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}
      
      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: deployment/Dockerfile.prod
          push: true
          tags: |
            ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.tag }}
            ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Production
    needs: [build]
    runs-on: [self-hosted, linux]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://safework.jclee.me
    
    steps:
      - name: Notify deployment
        run: |
          echo "üöÄ Docker image pushed to registry"
          echo "üì¶ Image: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:latest"
          echo "üîÑ ArgoCD will automatically sync the deployment"
      
      - name: Verify deployment
        run: |
          echo "‚è≥ Waiting for ArgoCD sync..."
          sleep 60
          
          for i in {1..10}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://safework.jclee.me/health || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "‚úÖ Application is healthy!"
              break
            else
              echo "‚è≥ Waiting for application... (attempt $i/10, status: $HTTP_STATUS)"
              sleep 30
            fi
          done